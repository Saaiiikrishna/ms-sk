/* TEMPORARILY DISABLED FOR BUILD
package com.mysillydreams.auth.config;

import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;
import org.springframework.boot.actuate.info.InfoContributor;
import org.springframework.boot.actuate.info.InfoEndpoint;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.vault.core.VaultOperations;

import javax.sql.DataSource;
import java.sql.Connection;
import java.time.LocalDateTime;
import java.util.Map;

/**
 * Monitoring and observability configuration for Auth Service.
 * Provides custom health checks, metrics, and monitoring capabilities.
 */
@Configuration
public class MonitoringConfiguration {

    @Autowired
    private MeterRegistry meterRegistry;

    /**
     * Custom health indicator for Vault connectivity
     */
    @Bean
    public HealthIndicator vaultHealthIndicator(VaultOperations vaultOperations) {
        return new VaultHealthIndicator(vaultOperations);
    }

    /**
     * Custom health indicator for database connectivity
     */
    @Bean
    public HealthIndicator databaseHealthIndicator(DataSource dataSource) {
        return new DatabaseHealthIndicator(dataSource);
    }

    /**
     * Custom health indicator for JWT secret availability
     */
    @Bean
    public HealthIndicator jwtHealthIndicator(VaultOperations vaultOperations) {
        return new JwtHealthIndicator(vaultOperations);
    }

    /**
     * Authentication metrics bean
     */
    @Bean
    public AuthenticationMetrics authenticationMetrics() {
        return new AuthenticationMetrics(meterRegistry);
    }

    /**
     * Application info contributor
     */
    @Bean
    public InfoContributor customInfoContributor() {
        return builder -> builder
            .withDetail("app", Map.of(
                "name", "MySillyDreams Auth Service",
                "version", "1.0.0",
                "description", "Authentication and authorization service",
                "build-time", LocalDateTime.now().toString()
            ))
            .withDetail("features", Map.of(
                "vault-integration", true,
                "refresh-tokens", true,
                "rate-limiting", true,
                "security-headers", true,
                "mfa-support", true
            ))
            .withDetail("security", Map.of(
                "jwt-algorithm", "HS512",
                "token-expiration", "1 hour",
                "refresh-token-expiration", "7 days",
                "max-concurrent-sessions", 5
            ));
    }

    /**
     * Vault health indicator implementation
     */
    public static class VaultHealthIndicator implements HealthIndicator {
        private final VaultOperations vaultOperations;

        public VaultHealthIndicator(VaultOperations vaultOperations) {
            this.vaultOperations = vaultOperations;
        }

        @Override
        public Health health() {
            try {
                // Test Vault connectivity by checking if we can read a simple path
                vaultOperations.read("sys/health");
                return Health.up()
                    .withDetail("vault", "Connected")
                    .withDetail("status", "Healthy")
                    .build();
            } catch (Exception e) {
                return Health.down()
                    .withDetail("vault", "Connection failed")
                    .withDetail("error", e.getMessage())
                    .build();
            }
        }
    }

    /**
     * Database health indicator implementation
     */
    public static class DatabaseHealthIndicator implements HealthIndicator {
        private final DataSource dataSource;

        public DatabaseHealthIndicator(DataSource dataSource) {
            this.dataSource = dataSource;
        }

        @Override
        public Health health() {
            try (Connection connection = dataSource.getConnection()) {
                if (connection.isValid(5)) {
                    return Health.up()
                        .withDetail("database", "Connected")
                        .withDetail("status", "Healthy")
                        .withDetail("url", connection.getMetaData().getURL())
                        .build();
                } else {
                    return Health.down()
                        .withDetail("database", "Connection invalid")
                        .build();
                }
            } catch (Exception e) {
                return Health.down()
                    .withDetail("database", "Connection failed")
                    .withDetail("error", e.getMessage())
                    .build();
            }
        }
    }

    /**
     * JWT health indicator implementation
     */
    public static class JwtHealthIndicator implements HealthIndicator {
        private final VaultOperations vaultOperations;

        public JwtHealthIndicator(VaultOperations vaultOperations) {
            this.vaultOperations = vaultOperations;
        }

        @Override
        public Health health() {
            try {
                // Check if JWT secrets are available in Vault
                var response = vaultOperations.read("secret/jwt");
                if (response != null && response.getData() != null) {
                    boolean hasSigningKey = response.getData().containsKey("signing-key");
                    boolean hasRefreshKey = response.getData().containsKey("refresh-signing-key");
                    
                    if (hasSigningKey && hasRefreshKey) {
                        return Health.up()
                            .withDetail("jwt-secrets", "Available")
                            .withDetail("signing-key", "Present")
                            .withDetail("refresh-key", "Present")
                            .build();
                    } else {
                        return Health.down()
                            .withDetail("jwt-secrets", "Incomplete")
                            .withDetail("signing-key", hasSigningKey ? "Present" : "Missing")
                            .withDetail("refresh-key", hasRefreshKey ? "Present" : "Missing")
                            .build();
                    }
                } else {
                    return Health.down()
                        .withDetail("jwt-secrets", "Not found")
                        .build();
                }
            } catch (Exception e) {
                return Health.down()
                    .withDetail("jwt-secrets", "Check failed")
                    .withDetail("error", e.getMessage())
                    .build();
            }
        }
    }

    /**
     * Authentication metrics for monitoring
     */
    public static class AuthenticationMetrics {
        private final Counter loginAttempts;
        private final Counter loginSuccesses;
        private final Counter loginFailures;
        private final Counter tokenRefreshes;
        private final Counter tokenRevocations;
        private final Timer loginDuration;
        private final Timer tokenGenerationDuration;

        public AuthenticationMetrics(MeterRegistry meterRegistry) {
            this.loginAttempts = Counter.builder("auth.login.attempts")
                .description("Total number of login attempts")
                .register(meterRegistry);
            
            this.loginSuccesses = Counter.builder("auth.login.successes")
                .description("Number of successful logins")
                .register(meterRegistry);
            
            this.loginFailures = Counter.builder("auth.login.failures")
                .description("Number of failed logins")
                .tag("reason", "unknown")
                .register(meterRegistry);
            
            this.tokenRefreshes = Counter.builder("auth.token.refreshes")
                .description("Number of token refreshes")
                .register(meterRegistry);
            
            this.tokenRevocations = Counter.builder("auth.token.revocations")
                .description("Number of token revocations")
                .register(meterRegistry);
            
            this.loginDuration = Timer.builder("auth.login.duration")
                .description("Time taken for login operations")
                .register(meterRegistry);
            
            this.tokenGenerationDuration = Timer.builder("auth.token.generation.duration")
                .description("Time taken for token generation")
                .register(meterRegistry);
        }

        public void recordLoginAttempt() {
            loginAttempts.increment();
        }

        public void recordLoginSuccess() {
            loginSuccesses.increment();
        }

        public void recordLoginFailure(String reason) {
            Counter.builder("auth.login.failures")
                .tag("reason", reason)
                .register(loginFailures.getId().getMeterRegistry())
                .increment();
        }

        public void recordTokenRefresh() {
            tokenRefreshes.increment();
        }

        public void recordTokenRevocation() {
            tokenRevocations.increment();
        }

        public Timer.Sample startLoginTimer() {
            return Timer.start(loginDuration.getId().getMeterRegistry());
        }

        public Timer.Sample startTokenGenerationTimer() {
            return Timer.start(tokenGenerationDuration.getId().getMeterRegistry());
        }
    }
}
*/
